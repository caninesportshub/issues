name: Sync Issues to Private Repos

on:
  issues:
    types: [opened, edited]

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Parse and Mirror Issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PRIVATE_REPOS_TOKEN }}  # Your fine-grained PAT
          script: |
            // No need to import or create Octokit — 'github' is already available and authenticated!

            // Get issue details
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const labels = issue.data.labels.map(l => l.name.toLowerCase());

            let issueType = 'bug';  // default fallback
            if (labels.includes('enhancement') || labels.includes('feature-request')) {
              issueType = 'enhancement';
            } else if (labels.includes('bug') || labels.includes('bug-report')) {
              issueType = 'bug';
            }

            console.log(`Detected issue type from labels: "${issueType}"`);            

            const body = issue.data.body || '';
            console.log('Full issue body for debug:', body);  // Logs the raw body — very helpful!

            let platform = 'untriaged';
            let platformsDetected = [];
            
            // Find the Platform section (case-insensitive, handles "Platform", "Platform(s)", etc.)
            const platformSectionMatch = body.match(/###\s*Platform(?:\s*\(s\))?\s*([\s\S]*?)(?=###|$)/i);
            
            if (platformSectionMatch && platformSectionMatch[1]) {
              const sectionContent = platformSectionMatch[1].trim();
            
              // First, try checkbox format (standard for multi-select)
              const checkboxMatches = [...sectionContent.matchAll(/- \[(x| )\]\s*(.+)/gi)];
            
              if (checkboxMatches.length > 0) {
                for (const match of checkboxMatches) {
                  const checked = match[1].toLowerCase() === 'x';
                  const value = match[2].trim();
            
                  if (checked) {
                    const lowerValue = value.toLowerCase();
                    if (lowerValue.includes('web')) platformsDetected.push('web');
                    if (lowerValue.includes('phone') || lowerValue.includes('tablet') || lowerValue.includes('mobile')) {
                      platformsDetected.push('mobile');
                    }
                  }
                }
              } else {
                // Fallback: plain text (single-select old style, or comma/newline separated)
                // Split on commas, newlines, or both; clean up
                const linesOrItems = sectionContent
                  .split(/[\n,]+/)                     // split on newlines OR commas
                  .map(item => item.trim())
                  .filter(item => item.length > 0);
            
                for (const item of linesOrItems) {
                  const lowerItem = item.toLowerCase();
                  if (lowerItem.includes('web')) platformsDetected.push('web');
                  if (lowerItem.includes('phone') || lowerItem.includes('tablet') || lowerItem.includes('mobile')) {
                    platformsDetected.push('mobile');
                  }
                }
              }
            }
            
            console.log(`Detected platforms: ${platformsDetected.join(', ') || 'none'}`);
            
            // Now decide target repo(s) — since we can have multiple, you have a few options:
            // OPTION A: Sync to BOTH repos if both platforms are selected (recommended for cross-platform bugs)
            // OPTION B: Sync only to one (e.g. prefer mobile if both, or pick first)
            // OPTION C: Sync to a shared repo + label accordingly
            
            // Here's OPTION A implementation (sync to all matching repos):
            
            if (platformsDetected.length === 0) {
              // Fallback: label public issue for manual triage
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['untriaged']
              });
              console.log('No platforms detected - labeled untriaged');
              return;
            }
            
            const targetRepos = new Set();  // avoid duplicates
            
            platformsDetected.forEach(p => {
              if (p === 'web') targetRepos.add('caninesportshub');
              if (p === 'mobile') targetRepos.add('mobile');
            });
            
            if (targetRepos.size === 0) {
              console.log('No matching repos found for detected platforms');
              return;
            }
            
            // Create mirrored issue in EACH target repo
            for (const targetRepo of targetRepos) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: targetRepo,
                title: `[Public #${context.issue.number}] ${issue.data.title}`,
                body: `Synced from public: ${issue.data.html_url}\n\n${body}`,
                labels: ['synced', issueType]
              });
              console.log(`Mirrored issue to: ${targetRepo}`);
            }
            
            // Optional: better comment on public issue
            const syncedToText = Array.from(targetRepos).join(' and ');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `This issue has been mirrored to the **${syncedToText}** private repo${targetRepos.size > 1 ? 's' : ''} for tracking. Thanks!`
            });
